---
import { Image, getImage } from "astro:assets";
const { id, img, subImages, title, categories, release } = Astro.props;
const assets = import.meta.glob<{ default: ImageMetadata }>("../assets/**/*");
const imgAsset = await assets[img]();
const optimizedImage = await getImage({
  src: imgAsset.default,
  quality: 85,
  format: "webp",
});

// スライダー用の画像アセット配列を作成
// subImagesが存在する場合はimgAssetの後にsubImagesのアセットを並べる
const subImageAssets =
  subImages && subImages.length > 0
    ? await Promise.all(subImages.map((subImage: string) => assets[subImage]()))
    : [];

const baseSliderImages =
  subImages && subImages.length > 0
    ? [imgAsset, ...subImageAssets]
    : [imgAsset];

// 最低4つになるように画像を繰り返す
// baseSliderImages全体を繰り返して、最低4つ以上になるようにする
const minImageCount = 4;
const repeatCount = Math.ceil(minImageCount / baseSliderImages.length);
const sliderImages: typeof baseSliderImages = [];
for (let i = 0; i < repeatCount; i++) {
  sliderImages.push(...baseSliderImages);
}

// アニメーション速度を画像数に応じて計算
// 基準: 4枚の画像で60秒（1枚あたり15秒）
// 画像数に比例してアニメーション時間を調整
const imageCount = sliderImages.length;
const baseDuration = 120; // 基準時間（秒）
const baseImageCount = 4; // 基準画像数
const animationDuration = (imageCount / baseImageCount) * baseDuration;
const animationDelay = -animationDuration / 2; // tickerの遅延時間
---

<div id={id} data-section class="relative h-screen w-full flex items-center">
  <div
    class="fixed top-0 left-0 w-full h-full object-cover opacity-0 z-[-1] transition-opacity duration-1000 blur-[10px] overflow-hidden scale-110"
    style={`background-image: url(${optimizedImage.src}); background-size: cover; background-position: center;`}
    data-background-image
  >
    <div class="absolute inset-0 bg-black/20"></div>
  </div>
  <a href={`/${id}`} class="overflow-x-clip w-full">
    <div class="flex shrink-0 overflow-hidden">
      <div
        class="flex shrink-0"
        style={`animation: ticker ${animationDuration}s ${animationDelay}s linear infinite;`}
      >
        {
          [...sliderImages, ...sliderImages].map((asset) => (
            <Image
              class="shrink-0 h-136 w-136 px-[0.7rem] md:px-[0.85rem] md:h-[51.7rem] md:w-[51.7rem]"
              src={asset.default}
              alt="slider-image"
              quality={85}
              format="webp"
            />
          ))
        }
      </div>
      <div
        class="flex shrink-0"
        style={`animation: ticker2 ${animationDuration}s linear infinite;`}
      >
        {
          [...sliderImages, ...sliderImages].map((asset) => (
            <Image
              class="shrink-0 h-136 w-136 px-[0.7rem] md:px-[0.85rem] md:h-[51.7rem] md:w-[51.7rem]"
              src={asset.default}
              alt="slider-image"
              quality={85}
              format="webp"
            />
          ))
        }
      </div>
    </div>
    <div
      class="text-white font-neue font-semibold capitalize px-[1.8rem] md:px-0 flex flex-col gap-[0.6rem] -mt-[2.2rem] relative z-10 md:gap-[0.7rem] md:-mt-[9.8rem] md:mx-56"
    >
      <h1 class="text-[3.2rem] leading-[100%] md:text-[6rem]">{title}</h1>
      <div class="flex flex-col gap-[1.4rem] md:gap-[1.6rem]">
        {
          release && (
            <p class="text-[1.3rem] leading-[100%] md:text-[1.8rem]">
              Release - {release}
            </p>
          )
        }
        <div class="flex flex-wrap gap-[0.7rem] md:gap-[1rem]">
          {
            categories?.map((category: string) => {
              return (
                <span class="inline-block font-abril border border-white text-[1rem] px-[0.6rem] py-[0.4rem] leading-[100%] tracking-[0.03rem] md:text-[1.2rem] font-medium md:px-[0.8rem] md:py-[0.5rem] rounded-full">
                  {category.toUpperCase()}
                </span>
              );
            })
          }
        </div>
      </div>
    </div>
  </a>
</div>
<script>
  import { activeIndex } from "../lib/store";

  function initBackgroundAnimations() {
    // セクションのみを対象にして、ローディングなど別要素のIDを除外
    const targets = document.querySelectorAll("[data-section]");
    let currentActiveIndex = -1;

    targets.forEach(function (target, index) {
      const backgroundImage = target.querySelector(
        "[data-background-image]",
      ) as HTMLElement;

      // 既存のオブザーバーをクリーンアップ
      const existingObserver = (target as any).__intersectionObserver;
      if (existingObserver) {
        existingObserver.disconnect();
      }

      var observer = new IntersectionObserver(
        function (entries) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting) {
              // 前の背景をフェードアウト
              if (currentActiveIndex >= 0 && currentActiveIndex !== index) {
                const prevTarget = targets[currentActiveIndex];
                const prevBackground = prevTarget?.querySelector(
                  "[data-background-image]",
                ) as HTMLElement;
                if (prevBackground) {
                  prevBackground.style.opacity = "0";
                }
              }

              // 現在の背景をフェードイン
              activeIndex.set(index);
              if (backgroundImage) {
                backgroundImage.style.opacity = "1";
              }
              currentActiveIndex = index;
            } else if (currentActiveIndex === index) {
              // 現在アクティブな背景が非表示になった場合のみフェードアウト
              if (backgroundImage) {
                backgroundImage.style.opacity = "0";
              }
            }
          });
        },
        {
          threshold: 0.5,
        },
      );
      observer.observe(target);
      // オブザーバーを保存（クリーンアップ用）
      (target as any).__intersectionObserver = observer;
    });

    // 初期表示：最初のセクションが表示されている場合は背景を表示
    const firstTarget = targets[0];
    if (firstTarget) {
      const firstBackground = firstTarget.querySelector(
        "[data-background-image]",
      ) as HTMLElement;
      if (firstBackground) {
        const rect = firstTarget.getBoundingClientRect();
        const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
        if (isVisible) {
          firstBackground.style.opacity = "1";
          currentActiveIndex = 0;
          activeIndex.set(0);
        }
      }
    }
  }

  // 初回読み込み時
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBackgroundAnimations);
  } else {
    initBackgroundAnimations();
  }

  // View Transitionsのページ遷移後にも実行
  // astro:page-loadはページが読み込まれた時に発火
  // astro:after-swapはページがスワップされた後に発火（フォールバック）
  document.addEventListener("astro:page-load", initBackgroundAnimations);
  document.addEventListener("astro:after-swap", initBackgroundAnimations);
</script>
